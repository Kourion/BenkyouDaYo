package jpp.qrcode;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;

public class QRCode {
	
	public static int length = 0;
	public static List<List<Boolean>> pubData = new ArrayList<List<Boolean>>();

	QRCode(List<List<Boolean>> data){
		if(data == null){
			throw new NullPointerException();
		}
		
		isSquare(data);	//Check Square Design
		
		String StringData = data.toString();
		//StringData = StringData.replaceAll("true", "\u2588");//Schwarze Pixel werden als Unicode Full Blocks (U+2588) und weiße Pixel als Unicode Light Shade (U+2591)
		//StringData = StringData.replaceAll("false", "\u2591");
		//StringData = StringData.replaceAll("[", " ");
		//StringData = StringData.replaceAll("]", "\n");
		//System.out.println(StringData);
		
		
		//int version = correctVersion(data); //getVersion
		
		QRCodeOrientation(data); //Check for correct Code Orientation
	}

	public void isSquare(List<List<Boolean>> data){
		//Trying to check for n fulfils the requirement "n x n".
		List<List<Boolean>> backup_data = data;
		if(data.size() != backup_data.remove(0).size()){	
			throw new InvalidQRCodeException("InvalidQRCodeException: The QRcode is not a square!");
		}	
	}
	
	public int correctVersion(List<List<Boolean>> data){
		/**Ein QR-Code der Version 1 ist 21x21 Module groß, mit jeder Version steigt die Seitenlänge des Codes dann um vier Module
		 *  (Version 2 ist dementsprechen 25x25 Module groß, Version 3 hat eine Seitenlänge von 29 Module, etc.).
		 *  @return The validatet version of the QRCode
		 */
		int version = data.size()-17;
		//System.out.println();
		version = version/4; 
		//System.out.println("Version: "+version);
		if(data.size()-(version*4+17)!=0){	//If during the version calculation above rounding occurred, then this check will fail and trigger the exception.
			throw new InvalidQRCodeException("Invalid QRCode Version");
		}else{
			length = data.size();
		}
		return version;
	}
	
	public void QRCodeOrientation(List<List<Boolean>> data){ //If false throw exception		//TODO
		// i Reihe, j Spalte
		int n = data.size(); //length = n
		for (int i = 0; i < n; i++) {
		}
		for (Iterator<List<Boolean>> iterator = data.iterator(); iterator.hasNext();) {
			 //System.out.println(iterator.next());		//TODO
			 iterator.next();
		}
	}//TODO
	
	public static QRCode fromFile(InputStream is) throws IOException{
	//public static List<List<Boolean>> fromFile(InputStream is) throws IOException{
		if(is == null){
			throw new NullPointerException();
		}
		
		List<List<Boolean>> data = new ArrayList<List<Boolean>>();
		List<Boolean> temp = new ArrayList<Boolean>();
		
		@SuppressWarnings({ "resource" })
		Scanner scan = new Scanner(is).useDelimiter("\\A");
		String msg = scan.hasNext() ? scan.next() : "";	
		
		int msgL = msg.length(), linecounter = 0, digitcounter = -1;
		boolean firstDigit = false, firstMatrixLineFinished = false;
		
		msg = msg.replace("\r\n", "\n");
		char[] msga = msg.toCharArray();
		//System.out.println(length);
		for(int i=0; i<msg.length(); i++){
			if(msga[i]=='#'||msga[i]=='ï'){ 
				int newI = i;
				String li = "";
				for(newI = i; (msga[newI]!='\r')&&(msga[newI]!='\n'); newI++){
					li = li +msga[newI];
					if((msga[newI]=='\r')||(msga[newI]=='\n')){ i = newI-2;}
				}
				if((msga[newI]=='\r')||(msga[newI]=='\n')){ i = newI;}
					//System.out.println(li+"-"+msga[i]+"-"+newI+"-"+i);	//Checks correct skipping of comment lines
				continue;
				}
			else if(msga[i]==' '){ }
				else if((msga[i]=='\r')||(msga[i]=='\n')){ 
					if(digitcounter > 0&&firstMatrixLineFinished == false){
						length = digitcounter;
						firstMatrixLineFinished = true;
						//System.out.println("digitcounter:"+digitcounter+" length:"+length);
					}
					if(linecounter == length&&temp != null&&firstMatrixLineFinished == true){
						//System.out.println(temp+"<-- Linec:"+linecounter+"		Sout1");
						data.add(temp); linecounter = 0; temp = new ArrayList<Boolean>();
						} 
					continue; 
					}
					else if ( Character.isDigit(msga[i])){ 
						if(msga[i] == '0') {
							temp.add(false);
							linecounter++;
							//System.out.println(linecounter);
								if(firstDigit==false){
									firstDigit = true;
									digitcounter = 1;
									//System.out.println("now"+digitcounter+"-"+linecounter);
								}else{ digitcounter++; } 
							} 
						if(msga[i] == '1') {
							temp.add(true);
							linecounter++;
								if(firstDigit==false){
									firstDigit = true;
									digitcounter = 1;
								}else{ digitcounter++; }  
							} 
					//System.out.println(linecounter);
					}
		}
		pubData = data;
		QRCode QRCodeData = new QRCode(data);
		//QRCodeData.clone();
		return QRCodeData;
	}
	
	public List<List<Boolean>> getData(){
		List<List<Boolean>> data2 = QRCode.pubData;
		return data2;
	}
	
	public String printQRCode(){
		List<List<Boolean>> msg = pubData;
		
		Object[] ObjectArray =  msg.toArray();
		System.out.println(ObjectArray[0].toString()+"			Sout2");
		String[] StringArray = new String[ObjectArray.length];
		for (int i = 0; i < ObjectArray.length; i++) {
			StringArray[i] = ObjectArray[i].toString();
		}
		System.out.println("SA1: "+StringArray[1]);
		//String smsg = msg.toString();
		//smsg = smsg.replaceAll("true", "\u2588");//Schwarze Pixel werden als Unicode Full Blocks (U+2588) und weiße Pixel als Unicode Light Shade (U+2591)
		//smsg = smsg.replaceAll("false", "\u2591");
		//smsg = smsg.replaceAll("[", "");
		//smsg = smsg.replaceAll("]", "\n");
		//System.out.println(smsg);
		return null;
	}
	
	/*
	 public int getVersion() (2 Punkte)
	 gibt die Version des vorliegenden QR-Codes zurück.
	   
	 public ErrorCorrection getErrorCorrectionLevel() (2 Punkte)
	 gibt das verwendete Fehlerkorrekturlevel zurück.
	   
	 public MaskPattern getMaskPattern() (2 Punkte)
	 gibt das zur Maskierung verwendete Muster zurück.  
	   
	 public String toString() (5 Punkte)
	 Diese Methode gibt die Informationen des QR-Codes nach folgendem Muster zurück:  
	 Version: 3 
	 ErrorCorrection: LOW
	 MaskPattern: MASK010   
	 Die Methoden hashCode() und equals sollen so implementiert werden, dass zwei QR-Codes gleich sind, wenn ihre Matrix gleich ist.
	
	public String decode() (20 Punkte)
	Diese Methode soll QR-Codes bis Version 3(inkl.) mit geringem Fehlerkorrekturlevel und Byte-Kodierung auslesen. Besitzt der QR-Code eine höhere Version oder ein höheres Level der Fehlerkorrektur, so soll die Dekodierung abgebrochen werden und eine aussagekräftige QRDecodeException geworfen werden. Das Auslesen der Daten beginnt in der rechten unteren Ecke, die Bits werden in der Reihenfolge MSB zu LSB ausgelesen. Die ersten 4 ausgelesenen Bits zeigen das Encoding an. Die Dekodierung soll nur fortgesetzt werden, wenn eine Byte-Kodierung verwendet wird. Andernfalls soll eine QRDecodeException mit aussagekräftiger Nachricht geworfen werden. Die nächsten 8 Bit enthalten die Anzahl der kodierten Nachrichtenbytes als binäre Zahl. Diese Anzahl an Bytes muss nun ausgelesen und in lesbare Zeichen umgewandelt werden. Der verwendete Standardzeichensatz ist der ISO 8859-1 Standard. Für die Codierung gilt:
	Encoding 	Bitfolge
	Numerisch   	0001
	Alphanumerisch 	0010
	Byte    	 	0100
	Kanji 	   		1000
	Hinweise:  

	Denken Sie daran, dass die Daten maskiert sind und entsprechend des festgestellten Musters demaskiert werden müssen.
	Es ist hilfreich, zunächst eine Matrix zu erstellen, die angibt, welche der Module durch Ausrichtungselemente oder die Formatinformationsmodule belegt sind. Die Tabelle unter http://www.thonky.com/qr-code-tutorial/alignment-pattern-locations gibt an, an welchen Positionen die Alignment Pattern platziert sind
	*
	*/
	
	public static void main(String[] args) throws IOException {
		//List<Boolean> w = new ArrayList<Boolean>();
		//w.add(true); w.add(false);
		//System.out.println(w);
		FileInputStream is = new FileInputStream(new File("C:/Users/Patrick/Desktop/Desktop/University/SS 2016/Java Praktikum/workspace/jpp.qrcode/beispiele/qr_tiny.txt") );
		QRCode qrc = fromFile(is);
		qrc.printQRCode();
	}
	
}
